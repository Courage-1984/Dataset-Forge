---
description: 
globs: 
alwaysApply: true
---
---
name: "Code Style Consistency for Dataset Forge"
description: Ensure consistent code formatting and style across all Dataset Forge project files
globs: ["**/*"]
alwaysApply: true
priority: 1
---

# Code Style Consistency for Dataset Forge

You are an expert code style analyst with a keen eye for pattern recognition and coding conventions. Your expertise lies in quickly identifying the stylistic patterns, architecture approaches, and coding preferences in existing codebases, then adapting new code to seamlessly integrate with those established patterns.

## Style Analysis Focus

Before generating or suggesting any code, analyze the codebase for:

- Naming conventions (snake_case for Python, PascalCase for classes)
- Indentation patterns (4 spaces, no tabs)
- Comment style and frequency
- Function and method size patterns
- Error handling approaches
- Import/module organization
- Functional vs OOP paradigm usage
- File organization and architecture patterns
- Testing methodologies
- State management patterns
- Code block formatting (brackets, spacing, etc.)

## Dataset Forge Style Profile

### Naming Conventions
- **Variables**: snake_case
- **Functions**: snake_case
- **Classes**: PascalCase
- **Constants**: UPPER_SNAKE_CASE
- **Files**: snake_case.py
- **Directories**: snake_case/

### Formatting
- **Indentation**:4 spaces (no tabs)
- **Line length**: 88 characters (Black formatter standard)
- **Bracket style**: Same line for opening, new line for closing
- **Spacing**: Space around operators, no space inside parentheses

### Architecture Patterns
- **Module organization**: Modular design with clear separation
- **Component structure**: menus/ (UI), actions/ (business logic), utils/ (utilities)
- **State management**: Centralized session state
- **Error handling**: Centralized error utilities with audio feedback

### Paradigm Preferences
- **Functional vs OOP**: Functional approach with classes for complex state
- **Patterns**: Lazy imports, centralized utilities, memory management
- **Immutability**: Prefer immutable operations where possible

### Documentation
- **Comment style**: Google-style docstrings
- **Documentation**: Comprehensive README and docs structure
- **README conventions**: Modular documentation with navigation

### Testing Approach
- **Testing framework**: pytest only
- **Test organization**: tests/test_utils/, tests/test_cli/
- **Test naming**: test_*.py files

## Dataset Forge Specific Patterns

### Import Organization
```python
# 1. Standard library imports
import os
import sys
from typing import List, Optional

# 2. Third-party imports
import numpy as np
import torch
from PIL import Image

# 3l imports (dataset_forge.*)
from dataset_forge.utils.memory_utils import clear_memory
from dataset_forge.utils.printing import print_info

# 4. Relative imports (if within same module)
from .utils import helper_function
```

### Error Handling Pattern
```python
from dataset_forge.utils.printing import print_error
from dataset_forge.utils.history_log import log_operation

try:
    # Operation code
    log_operation("operation_name", Operation details")
except Exception as e:
    print_error(f"Error during operation: {e}")
    log_operation("operation_name", f"Failed: {e}")
```

### Menu System Pattern
```python
from dataset_forge.utils.menu import show_menu
from dataset_forge.utils.color import Mocha

def my_menu():
    options =[object Object]
        1: (ption 1", function1),
        2: (ption 2", function2),
      0: (ðŸšª Exit", None),
    }
    
    while True:
        try:
            action = show_menu("Menu Title", options, Mocha.lavender)
            if action is None:
                break
            action()
        except (KeyboardInterrupt, EOFError):
            print_info("\nExiting...")
            break
```

## Style Consistency Best Practices

1. **Dont Refactor Beyond Scope**: Match the existing style without introducing broader changes
2. **Comment Adaptation**: Match the existing comment style and frequency
3. **Variable Naming**: Use consistent variable naming patterns even within new functions
4. **Paradigm Alignment**: Favor the dominant paradigm (functional, OOP, etc.) seen in the codebase
5**Library Usage**: Prefer libraries already in use rather than introducing new ones
6. **Gradual Enhancement**: Only introduce newer patterns if they're already appearing in more recent files7rganization Mirroring**: Structure new modules to mirror the organization of similar existing modules
8. **Specificity Over Assumptions**: If styles are inconsistent, ask rather than assume
9mentation Matching**: Match documentation style in tone, detail level, and format
10. **Testing Consistency**: Follow established testing patterns for new code

## Adaptation Techniques

Use these techniques to adapt your code to match the existing style:

1. **Pattern Mirroring**: Copy structural patterns from similar functions/components
2. **Variable Naming Dictionary**: Create a mapping of concept-to-name patterns
3. **Comment Density Matching**: Count comments-per-line-of-code and match
4**Error Pattern Replication**: Use identical error handling approaches
5. **Module Structure Cloning**: Organize new modules like existing ones6 **Import Order Replication**: Order imports using the same conventions
7. **Test Case Templating**: Base new tests on the structure of existing tests
8n Size Consistency**: Match the granularity of functions/methods
9. **State Management Consistency**: Use the same state management approaches
10. **Type Definition Matching**: Format type definitions consistently with existing ones